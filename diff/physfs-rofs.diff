diff -Naur --exclude=Makefile.in --exclude=aclocal.m4 --exclude='config.*' --exclude=configure --exclude=depcomp --exclude=install-sh --exclude=ltmain.sh --exclude=missing /home/patrice/src/cvs/Icculus/physfs-stable-1.0/archivers/Makefile.am physfs/archivers/Makefile.am
--- /home/patrice/src/cvs/Icculus/physfs-stable-1.0/archivers/Makefile.am	2007-05-05 23:27:01.000000000 +0200
+++ physfs/archivers/Makefile.am	2007-05-07 17:34:39.000000000 +0200
@@ -12,6 +12,7 @@
 	wad.c		\
 	hog.c		\
 	mvl.c		\
+	rofs.c		\
 	zip.c		\
 	qpak.c
 
diff -Naur --exclude=Makefile.in --exclude=aclocal.m4 --exclude='config.*' --exclude=configure --exclude=depcomp --exclude=install-sh --exclude=ltmain.sh --exclude=missing /home/patrice/src/cvs/Icculus/physfs-stable-1.0/archivers/rofs.c physfs/archivers/rofs.c
--- /home/patrice/src/cvs/Icculus/physfs-stable-1.0/archivers/rofs.c	1970-01-01 01:00:00.000000000 +0100
+++ physfs/archivers/rofs.c	2007-05-17 12:21:19.000000000 +0200
@@ -0,0 +1,923 @@
+/*
+ * Resident Evil 3 rofs<n>.dat support routines for PhysicsFS.
+ *
+ * This driver handles Resident Evil 3 archives.
+ *
+ * Please see the file LICENSE in the source's root directory.
+ *
+ * This file written by Patrice Mandin, based on the QPAK archiver by
+ *  Ryan C. Gordon.
+ */
+
+#if HAVE_CONFIG_H
+#  include <config.h>
+#endif
+
+#if (defined PHYSFS_SUPPORTS_ROFS)
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include "physfs.h"
+
+#define __PHYSICSFS_INTERNAL__
+#include "physfs_internal.h"
+
+typedef struct
+{
+    PHYSFS_uint32 startPos;
+    PHYSFS_uint32 size;
+    PHYSFS_uint32 rawStartPos; /* offset in archive to file header */
+    int compression;
+    int decrypted, depacked; /* status of data */
+    char name[16+16+16]; /* room to store /dir1/dir2/filename */
+    char *data; /* buffer to decrypted and depacked file */
+} ROFSentry;
+
+/* rofsinfo -> rofsentry level1 -> rofsentry level2 -> rofsentry files */
+
+typedef struct
+{
+    char *filename;
+    PHYSFS_sint64 last_mod_time;
+    PHYSFS_uint32 entryCount;
+    ROFSentry dirs[2];
+    ROFSentry *entries;
+} ROFSinfo;
+
+typedef struct
+{
+    void *handle;
+    ROFSentry *entry;
+    PHYSFS_uint32 curPos;
+} ROFSfileinfo;
+
+
+
+static void ROFS_dirClose(DirHandle *h);
+static PHYSFS_sint64 ROFS_read(FileHandle *handle, void *buffer,
+                              PHYSFS_uint32 objSize, PHYSFS_uint32 objCount);
+static PHYSFS_sint64 ROFS_write(FileHandle *handle, const void *buffer,
+                               PHYSFS_uint32 objSize, PHYSFS_uint32 objCount);
+static int ROFS_eof(FileHandle *handle);
+static PHYSFS_sint64 ROFS_tell(FileHandle *handle);
+static int ROFS_seek(FileHandle *handle, PHYSFS_uint64 offset);
+static PHYSFS_sint64 ROFS_fileLength(FileHandle *handle);
+static int ROFS_fileClose(FileHandle *handle);
+static int ROFS_isArchive(const char *filename, int forWriting);
+static DirHandle *ROFS_openArchive(const char *name, int forWriting);
+static LinkedStringList *ROFS_enumerateFiles(DirHandle *h,
+                                            const char *dirname,
+                                            int omitSymLinks);
+static int ROFS_exists(DirHandle *h, const char *name);
+static int ROFS_isDirectory(DirHandle *h, const char *name, int *fileExists);
+static int ROFS_isSymLink(DirHandle *h, const char *name, int *fileExists);
+static PHYSFS_sint64 ROFS_getLastModTime(DirHandle *h, const char *n, int *e);
+static FileHandle *ROFS_openRead(DirHandle *h, const char *name, int *exist);
+static FileHandle *ROFS_openWrite(DirHandle *h, const char *name);
+static FileHandle *ROFS_openAppend(DirHandle *h, const char *name);
+static int ROFS_remove(DirHandle *h, const char *name);
+static int ROFS_mkdir(DirHandle *h, const char *name);
+
+const PHYSFS_ArchiveInfo __PHYSFS_ArchiveInfo_ROFS =
+{
+    "ROFS",
+    ROFS_ARCHIVE_DESCRIPTION,
+    "Patrice Mandin <pmandin@caramail.com>",
+    "http://pmandin.atari.org/",
+};
+
+
+static const FileFunctions __PHYSFS_FileFunctions_ROFS =
+{
+    ROFS_read,       /* read() method       */
+    ROFS_write,      /* write() method      */
+    ROFS_eof,        /* eof() method        */
+    ROFS_tell,       /* tell() method       */
+    ROFS_seek,       /* seek() method       */
+    ROFS_fileLength, /* fileLength() method */
+    ROFS_fileClose   /* fileClose() method  */
+};
+
+
+const DirFunctions __PHYSFS_DirFunctions_ROFS =
+{
+    &__PHYSFS_ArchiveInfo_ROFS,
+    ROFS_isArchive,          /* isArchive() method      */
+    ROFS_openArchive,        /* openArchive() method    */
+    ROFS_enumerateFiles,     /* enumerateFiles() method */
+    ROFS_exists,             /* exists() method         */
+    ROFS_isDirectory,        /* isDirectory() method    */
+    ROFS_isSymLink,          /* isSymLink() method      */
+    ROFS_getLastModTime,     /* getLastModTime() method */
+    ROFS_openRead,           /* openRead() method       */
+    ROFS_openWrite,          /* openWrite() method      */
+    ROFS_openAppend,         /* openAppend() method     */
+    ROFS_remove,             /* remove() method         */
+    ROFS_mkdir,              /* mkdir() method          */
+    ROFS_dirClose            /* dirClose() method       */
+};
+
+
+
+static void ROFS_dirClose(DirHandle *h)
+{
+    ROFSinfo *info = ((ROFSinfo *) h->opaque);
+    free(info->filename);
+    free(info->entries);
+    free(info);
+    free(h);
+} /* ROFS_dirClose */
+
+/*--- Decryption ---*/
+
+typedef struct {
+	unsigned short offset;
+	unsigned short num_keys;
+	unsigned long length;
+	unsigned char ident[8];
+} rofs_dat_file_t;
+
+const unsigned short base_array[64]={
+	0x00e6, 0x01a4, 0x00e6, 0x01c5,
+	0x0130, 0x00e8, 0x03db, 0x008b,
+	0x0141, 0x018e, 0x03ae, 0x0139,
+	0x00f0, 0x027a, 0x02c9, 0x01b0,
+	0x01f7, 0x0081, 0x0138, 0x0285,
+	0x025a, 0x015b, 0x030f, 0x0335,
+	0x02e4, 0x01f6, 0x0143, 0x00d1,
+	0x0337, 0x0385, 0x007b, 0x00c6,
+	0x0335, 0x0141, 0x0186, 0x02a1,
+	0x024d, 0x0342, 0x01fb, 0x03e5,
+	0x01b0, 0x006d, 0x0140, 0x00c0,
+	0x0386, 0x016b, 0x020b, 0x009a,
+	0x0241, 0x00de, 0x015e, 0x035a,
+	0x025b, 0x0154, 0x0068, 0x02e8,
+	0x0321, 0x0071, 0x01b0, 0x0232,
+	0x02d9, 0x0263, 0x0164, 0x0290
+};
+
+static PHYSFS_uint8 rofs_next_key(PHYSFS_uint32 *key)
+{
+	*key *= 0x5d588b65;
+	*key += 0x8000000b;
+
+	return (*key >> 24);
+}
+
+static void rofs_decrypt_block(unsigned char *src, PHYSFS_uint32 key, PHYSFS_uint32 length)
+{
+	PHYSFS_uint8 xor_key, base_index;
+	int i, block_index;
+	
+	xor_key = rofs_next_key(&key);
+	base_index = rofs_next_key(&key) % 0x3f;
+
+	block_index = 0;
+	for (i=0; i<length; i++) {
+		if (block_index>base_array[base_index]) {
+			base_index = rofs_next_key(&key) % 0x3f;
+			xor_key = rofs_next_key(&key);
+			block_index = 0;
+		}
+		src[i] ^= xor_key;
+		block_index++;
+	}
+}
+
+static int rofs_decrypt(void *fh, ROFSentry *entry)
+{
+    PHYSFS_sint64 location, offset, file_offset;
+    rofs_dat_file_t file_header;
+    int rc = 0, i, data_offset;
+    PHYSFS_uint32 *array_alloc = NULL;
+    PHYSFS_uint32 *array_keys, *array_length;
+
+    /* Save current position */
+    location = __PHYSFS_platformTell(fh);
+
+    __PHYSFS_platformSeek(fh, entry->rawStartPos);
+
+    /* Read header */
+    if (__PHYSFS_platformRead(fh, &file_header, sizeof(rofs_dat_file_t), 1) != 1)
+        goto rofs_decrypt_failed;
+
+    file_header.num_keys = PHYSFS_swapULE16(file_header.num_keys);
+    file_header.offset = PHYSFS_swapULE16(file_header.offset);
+
+    /* Alloc mem to read array of keys */
+    array_alloc = (PHYSFS_uint32 *) malloc(file_header.num_keys*2*sizeof(PHYSFS_uint32));
+    if (!array_alloc)
+        goto rofs_decrypt_failed;
+
+    /* Read keys */
+    if (__PHYSFS_platformRead(fh, array_alloc, sizeof(PHYSFS_uint32), file_header.num_keys*2) != file_header.num_keys*2)
+        goto rofs_decrypt_failed;
+
+    array_keys = array_alloc;
+    array_length = &array_alloc[file_header.num_keys];
+
+    file_offset = entry->rawStartPos + file_header.offset;
+    data_offset = 0;
+    rc = 1;
+    for (i=0; i<file_header.num_keys; i++) {
+        array_keys[i] = PHYSFS_swapULE32(array_keys[i]);
+        array_length[i] = PHYSFS_swapULE32(array_length[i]);
+
+        if (!__PHYSFS_platformSeek(fh, file_offset)) {
+            rc = 0;
+            break;
+	}
+
+        if (__PHYSFS_platformRead(fh, &entry->data[data_offset], array_length[i], 1) != 1) {
+            rc = 0;
+            break;
+	}
+
+        rofs_decrypt_block(&entry->data[data_offset], array_keys[i], array_length[i]);
+
+	file_offset += array_length[i];
+	data_offset += array_length[i];
+    }
+
+rofs_decrypt_failed:
+    if (array_alloc)
+        free(array_alloc);
+
+    /* Restore location */
+    __PHYSFS_platformSeek(fh, location);
+
+    return rc;
+}
+
+/*--- Decompression ---*/
+
+static int rofs_depack(void *fh, ROFSentry *entry)
+{
+	return 0;
+}
+
+static PHYSFS_sint64 ROFS_read(FileHandle *handle, void *buffer,
+                              PHYSFS_uint32 objSize, PHYSFS_uint32 objCount)
+{
+    ROFSfileinfo *finfo = (ROFSfileinfo *) (handle->opaque);
+    ROFSentry *entry = finfo->entry;
+    PHYSFS_uint32 bytesLeft = entry->size - finfo->curPos;
+    PHYSFS_uint32 objsLeft = (bytesLeft / objSize);
+    PHYSFS_sint64 rc;
+
+    if (objsLeft < objCount)
+        objCount = objsLeft;
+
+	/*printf("rofs_read(%d,%d),curPos=%d\n",objSize,objCount, finfo->curPos);*/
+
+    /* Allocate buffer if needed */
+    if (!entry->data) {
+        entry->data = calloc(1, entry->size);
+        if (!entry->data) {
+            return(0);
+	}
+	/*printf("rofs_read(): allocated %d bytes at 0x%08x\n", entry->size, entry->data);*/
+    }
+
+    /* Decrypt if needed */
+    if (!entry->decrypted) {
+	/*printf("rofs_read(): decrypt needed\n");*/
+        entry->decrypted = rofs_decrypt(finfo->handle, entry);
+        if (!entry->decrypted) {
+            return(0);
+	}
+    }
+
+    /* Depack if needed */
+    if (entry->compression && !entry->depacked) {
+	/*printf("rofs_read(): depack needed\n");*/
+        entry->depacked = rofs_depack(finfo->handle, entry);
+        if (!entry->depacked) {
+            return(0);
+	}
+    }
+
+    rc = objCount;
+    memcpy(buffer, &entry->data[finfo->curPos], objSize * objCount);
+    finfo->curPos += (PHYSFS_uint32) (objSize * rc);
+
+    return(rc);
+} /* ROFS_read */
+
+
+static PHYSFS_sint64 ROFS_write(FileHandle *handle, const void *buffer,
+                               PHYSFS_uint32 objSize, PHYSFS_uint32 objCount)
+{
+    BAIL_MACRO(ERR_NOT_SUPPORTED, -1);
+} /* ROFS_write */
+
+
+static int ROFS_eof(FileHandle *handle)
+{
+    ROFSfileinfo *finfo = (ROFSfileinfo *) (handle->opaque);
+    ROFSentry *entry = finfo->entry;
+    return(finfo->curPos >= entry->size);
+} /* ROFS_eof */
+
+
+static PHYSFS_sint64 ROFS_tell(FileHandle *handle)
+{
+    return(((ROFSfileinfo *) (handle->opaque))->curPos);
+} /* ROFS_tell */
+
+
+static int ROFS_seek(FileHandle *handle, PHYSFS_uint64 offset)
+{
+    ROFSfileinfo *finfo = (ROFSfileinfo *) (handle->opaque);
+    ROFSentry *entry = finfo->entry;
+    int rc;
+
+    BAIL_IF_MACRO(offset < 0, ERR_INVALID_ARGUMENT, 0);
+    BAIL_IF_MACRO(offset >= entry->size, ERR_PAST_EOF, 0);
+
+    finfo->curPos = (PHYSFS_uint32) offset;
+
+    return(rc);
+} /* ROFS_seek */
+
+
+static PHYSFS_sint64 ROFS_fileLength(FileHandle *handle)
+{
+    ROFSfileinfo *finfo = ((ROFSfileinfo *) handle->opaque);
+    return((PHYSFS_sint64) finfo->entry->size);
+} /* ROFS_fileLength */
+
+
+static int ROFS_fileClose(FileHandle *handle)
+{
+    ROFSfileinfo *finfo = ((ROFSfileinfo *) handle->opaque);
+    ROFSentry *entry = finfo->entry;
+    BAIL_IF_MACRO(!__PHYSFS_platformClose(finfo->handle), NULL, 0);
+    if (entry->data) {
+	/*printf("rofs: fileclose(0x%08x)\n", entry->data);*/
+        free(entry->data);
+        entry->data = NULL;
+        entry->depacked = entry->decrypted = 0;
+    }
+    free(finfo);
+    free(handle);
+    return(1);
+} /* ROFS_fileClose */
+
+/* All rofs<n>.dat files start with this */
+static const char rofs_id[14]={
+	3, 0, 0, 0,
+	1, 0, 0, 0,
+	4, 0, 0, 0,
+	0, 1
+};
+
+static int rofs_open(const char *filename, int forWriting,
+                    void **fh, PHYSFS_uint32 *count)
+{
+    PHYSFS_uint8 buf[14];
+    PHYSFS_uint32 num_files;
+
+    *fh = NULL;
+    BAIL_IF_MACRO(forWriting, ERR_ARC_IS_READ_ONLY, 0);
+
+    *fh = __PHYSFS_platformOpenRead(filename);
+    BAIL_IF_MACRO(*fh == NULL, NULL, 0);
+    
+    /* Check if known header */
+    if (__PHYSFS_platformRead(*fh, buf, 14, 1) != 1)
+        goto openRofs_failed;
+
+    if (memcmp(buf, rofs_id, 14) != 0)
+    {
+        __PHYSFS_setError(ERR_UNSUPPORTED_ARCHIVE);
+        goto openRofs_failed;
+    } /* if */
+
+    /* Seek to offset 0x1000 to read number of files */
+    if (!__PHYSFS_platformSeek(*fh, 0x1000))
+        goto openRofs_failed;
+
+    if (__PHYSFS_platformRead(*fh, &num_files, sizeof (PHYSFS_uint32), 1) != 1)
+        goto openRofs_failed;
+
+    *count = PHYSFS_swapULE32(num_files);
+	/*printf("rofs: %d files in archive\n", *count);*/
+
+    return(1);
+
+openRofs_failed:
+    if (*fh != NULL)
+        __PHYSFS_platformClose(*fh);
+
+    *count = -1;
+    *fh = NULL;
+    return(0);
+} /* rofs_open */
+
+
+static int ROFS_isArchive(const char *filename, int forWriting)
+{
+    void *fh;
+    PHYSFS_uint32 fileCount;
+    int retval = rofs_open(filename, forWriting, &fh, &fileCount);
+
+    if (fh != NULL)
+        __PHYSFS_platformClose(fh);
+
+    return(retval);
+} /* ROFS_isArchive */
+
+
+static int rofs_entry_cmp(void *_a, PHYSFS_uint32 one, PHYSFS_uint32 two)
+{
+    ROFSentry *a = (ROFSentry *) _a;
+    return(strcmp(a[one].name, a[two].name));
+} /* rofs_entry_cmp */
+
+
+static void rofs_entry_swap(void *_a, PHYSFS_uint32 one, PHYSFS_uint32 two)
+{
+    ROFSentry tmp;
+    ROFSentry *first = &(((ROFSentry *) _a)[one]);
+    ROFSentry *second = &(((ROFSentry *) _a)[two]);
+    memcpy(&tmp, first, sizeof (ROFSentry));
+    memcpy(first, second, sizeof (ROFSentry));
+    memcpy(second, &tmp, sizeof (ROFSentry));
+} /* rofs_entry_swap */
+
+
+static int rofs_read_filename(void *fh, unsigned char *dst, int dst_len)
+{
+    int i = 0;
+
+    memset(dst, '\0', dst_len);
+
+    do {
+        unsigned char c;
+
+        if (__PHYSFS_platformRead(fh, &c, 1, 1) != 1) {
+            return(0);
+        }
+        dst[i] = tolower(c);
+    } while (dst[i++] != '\0');
+
+    return(1);
+}
+
+static int rofs_load_header(void *fh, ROFSinfo *info)
+{
+    PHYSFS_sint64 location, loclevel2;
+
+    /* Save current position */
+    location = __PHYSFS_platformTell(fh);
+
+    /* Read directory name to be appended to all files */
+    if (__PHYSFS_platformSeek(fh, 0x15) != 1) {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    }
+
+    /* Till now all tested rofs.dat file archives have 2 levels */
+    if (!rofs_read_filename(fh, info->dirs[0].name, sizeof(info->dirs[0].name))) {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    }
+
+    loclevel2 = 30 + strlen(info->dirs[0].name);
+    if (__PHYSFS_platformSeek(fh, loclevel2) != 1)
+    {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    } /* if */
+
+    if (!rofs_read_filename(fh, info->dirs[1].name, sizeof(info->dirs[1].name))) {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    }
+
+    /* Back to directory */
+    if (__PHYSFS_platformSeek(fh, location) != 1)
+    {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    } /* if */
+
+    return(1);
+}
+
+static int rofs_load_entries(const char *name, int forWriting, ROFSinfo *info)
+{
+    void *fh = NULL;
+    PHYSFS_uint32 fileCount;
+    PHYSFS_sint64 location;
+    ROFSentry *entry;
+    char *ptr;
+    char compstring[8];
+    char shortname[16];
+    int i;
+
+    BAIL_IF_MACRO(!rofs_open(name, forWriting, &fh, &fileCount), NULL, 0);
+
+    if (!rofs_load_header(fh, info)) {
+        __PHYSFS_platformClose(fh);
+        return(0);
+    }
+
+    info->entryCount = fileCount;
+    info->entries = (ROFSentry *) malloc(sizeof (ROFSentry) * fileCount);
+    if (info->entries == NULL)
+    {
+        __PHYSFS_platformClose(fh);
+        BAIL_MACRO(ERR_OUT_OF_MEMORY, 0);
+    } /* if */
+
+    for (entry = info->entries; fileCount > 0; fileCount--, entry++)
+    {
+        if (__PHYSFS_platformRead(fh, &entry->rawStartPos, sizeof(entry->rawStartPos), 1) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+
+	entry->startPos = 0;
+
+        entry->rawStartPos = PHYSFS_swapULE32(entry->rawStartPos) << 3;
+
+        if (__PHYSFS_platformRead(fh, &entry->size, sizeof(entry->size), 1) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+
+        entry->size = 0; /* Not real size */
+
+        /* Read NULL terminated string */
+        if (!rofs_read_filename(fh, shortname, sizeof(shortname))) {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        }
+
+        /* Generate long filename */
+	sprintf(entry->name, "%s/%s/%s", info->dirs[0].name,
+		info->dirs[1].name, shortname);
+	
+        /* Now go read real file size */
+        location = __PHYSFS_platformTell(fh);
+
+        if (__PHYSFS_platformSeek(fh, entry->rawStartPos + 4) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+
+        if (__PHYSFS_platformRead(fh, &entry->size, sizeof(entry->size), 1) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+
+        entry->size = PHYSFS_swapULE32(entry->size);
+	/*printf("rofs_load_entries: %s, %d bytes\n", shortname, entry->size);*/
+
+	/* Read compression string */
+        if (__PHYSFS_platformRead(fh, compstring, sizeof(compstring), 1) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+
+	for (i=0; i<8; i++) {
+		compstring[i] ^= compstring[7];
+	}
+
+	entry->compression = (strcmp("Hi_Comp", compstring)==0);
+
+	entry->decrypted =
+	entry->depacked = 0;
+	entry->data = NULL;
+
+        /* Back to directory */
+        if (__PHYSFS_platformSeek(fh, location) != 1)
+        {
+            __PHYSFS_platformClose(fh);
+            return(0);
+        } /* if */
+    } /* for */
+
+    __PHYSFS_platformClose(fh);
+
+    __PHYSFS_sort(info->entries, info->entryCount,
+                  rofs_entry_cmp, rofs_entry_swap);
+    return(1);
+} /* rofs_load_entries */
+
+
+static DirHandle *ROFS_openArchive(const char *name, int forWriting)
+{
+    ROFSinfo *info;
+    DirHandle *retval = malloc(sizeof (DirHandle));
+    PHYSFS_sint64 modtime = __PHYSFS_platformGetLastModTime(name);
+
+    BAIL_IF_MACRO(retval == NULL, ERR_OUT_OF_MEMORY, NULL);
+    info = retval->opaque = malloc(sizeof (ROFSinfo));
+    if (info == NULL)
+    {
+        __PHYSFS_setError(ERR_OUT_OF_MEMORY);
+        goto ROFS_openArchive_failed;
+    } /* if */
+
+    memset(info, '\0', sizeof (ROFSinfo));
+
+    info->filename = (char *) malloc(strlen(name) + 1);
+    if (info->filename == NULL)
+    {
+        __PHYSFS_setError(ERR_OUT_OF_MEMORY);
+        goto ROFS_openArchive_failed;
+    } /* if */
+
+    if (!rofs_load_entries(name, forWriting, info))
+        goto ROFS_openArchive_failed;
+
+    strcpy(info->filename, name);
+    info->last_mod_time = modtime;
+    retval->funcs = &__PHYSFS_DirFunctions_ROFS;
+    return(retval);
+
+ROFS_openArchive_failed:
+    if (retval != NULL)
+    {
+        if (retval->opaque != NULL)
+        {
+            if (info->filename != NULL)
+                free(info->filename);
+            if (info->entries != NULL)
+                free(info->entries);
+            free(info);
+        } /* if */
+        free(retval);
+    } /* if */
+
+    return(NULL);
+} /* ROFS_openArchive */
+
+
+static PHYSFS_sint32 rofs_find_start_of_dir(ROFSinfo *info, const char *path,
+                                            int stop_on_first_find)
+{
+    PHYSFS_sint32 lo = 0;
+    PHYSFS_sint32 hi = (PHYSFS_sint32) (info->entryCount - 1);
+    PHYSFS_sint32 middle;
+    PHYSFS_uint32 dlen = strlen(path);
+    PHYSFS_sint32 retval = -1;
+    const char *name;
+    int rc;
+
+    if (*path == '\0')  /* root dir? */
+        return(0);
+
+    if ((dlen > 0) && (path[dlen - 1] == '/')) /* ignore trailing slash. */
+        dlen--;
+
+    while (lo <= hi)
+    {
+        middle = lo + ((hi - lo) / 2);
+        name = info->entries[middle].name;
+        rc = strncmp(path, name, dlen);
+        if (rc == 0)
+        {
+            char ch = name[dlen];
+            if (ch < '/') /* make sure this isn't just a substr match. */
+                rc = -1;
+            else if (ch > '/')
+                rc = 1;
+            else 
+            {
+                if (stop_on_first_find) /* Just checking dir's existance? */
+                    return(middle);
+
+                if (name[dlen + 1] == '\0') /* Skip initial dir entry. */
+                    return(middle + 1);
+
+                /* there might be more entries earlier in the list. */
+                retval = middle;
+                hi = middle - 1;
+            } /* else */
+        } /* if */
+
+        if (rc > 0)
+            lo = middle + 1;
+        else
+            hi = middle - 1;
+    } /* while */
+
+    return(retval);
+} /* rofs_find_start_of_dir */
+
+
+static LinkedStringList *ROFS_enumerateFiles(DirHandle *h,
+                                            const char *dirname,
+                                            int omitSymLinks)
+{
+    ROFSinfo *info = ((ROFSinfo *) h->opaque);
+    LinkedStringList *retval = NULL, *p = NULL;
+    PHYSFS_sint32 dlen, dlen_inc, max, i;
+
+    i = rofs_find_start_of_dir(info, dirname, 0);
+    BAIL_IF_MACRO(i == -1, ERR_NO_SUCH_FILE, NULL);
+
+    dlen = strlen(dirname);
+    if ((dlen > 0) && (dirname[dlen - 1] == '/')) /* ignore trailing slash. */
+        dlen--;
+
+    dlen_inc = ((dlen > 0) ? 1 : 0) + dlen;
+    max = (PHYSFS_sint32) info->entryCount;
+    while (i < max)
+    {
+        char *add;
+        char *ptr;
+        PHYSFS_sint32 ln;
+        char *e = info->entries[i].name;
+        if ((dlen) && ((strncmp(e, dirname, dlen)) || (e[dlen] != '/')))
+            break;  /* past end of this dir; we're done. */
+
+        add = e + dlen_inc;
+        ptr = strchr(add, '/');
+        ln = (PHYSFS_sint32) ((ptr) ? ptr-add : strlen(add));
+        retval = __PHYSFS_addToLinkedStringList(retval, &p, add, ln);
+        ln += dlen_inc;  /* point past entry to children... */
+
+        /* increment counter and skip children of subdirs... */
+        while ((++i < max) && (ptr != NULL))
+        {
+            char *e_new = info->entries[i].name;
+            if ((strncmp(e, e_new, ln) != 0) || (e_new[ln] != '/'))
+                break;
+        } /* while */
+    } /* while */
+
+    return(retval);
+} /* ROFS_enumerateFiles */
+
+
+static ROFSentry *rofs_find_entry(ROFSinfo *info, const char *path, int *isDir)
+{
+    ROFSentry *a = info->entries;
+    PHYSFS_sint32 pathlen = strlen(path);
+    PHYSFS_sint32 lo = 0;
+    PHYSFS_sint32 hi = (PHYSFS_sint32) (info->entryCount - 1);
+    PHYSFS_sint32 middle;
+    const char *thispath = NULL;
+    int rc;
+
+    while (lo <= hi)
+    {
+        middle = lo + ((hi - lo) / 2);
+        thispath = a[middle].name;
+        rc = strncmp(path, thispath, pathlen);
+
+        if (rc > 0)
+            lo = middle + 1;
+
+        else if (rc < 0)
+            hi = middle - 1;
+
+        else /* substring match...might be dir or entry or nothing. */
+        {
+            if (isDir != NULL)
+            {
+                *isDir = (thispath[pathlen] == '/');
+                if (*isDir)
+                    return(NULL);
+            } /* if */
+
+            if (thispath[pathlen] == '\0') /* found entry? */
+                return(&a[middle]);
+            else
+                hi = middle - 1;  /* adjust search params, try again. */
+        } /* if */
+    } /* while */
+
+    if (isDir != NULL)
+        *isDir = 0;
+
+    BAIL_MACRO(ERR_NO_SUCH_FILE, NULL);
+} /* rofs_find_entry */
+
+
+static int ROFS_exists(DirHandle *h, const char *name)
+{
+    int isDir;    
+    ROFSinfo *info = (ROFSinfo *) h->opaque;
+    ROFSentry *entry = rofs_find_entry(info, name, &isDir);
+    return((entry != NULL) || (isDir));
+} /* ROFS_exists */
+
+
+static int ROFS_isDirectory(DirHandle *h, const char *name, int *fileExists)
+{
+    ROFSinfo *info = (ROFSinfo *) h->opaque;
+    int isDir;
+    ROFSentry *entry = rofs_find_entry(info, name, &isDir);
+
+    *fileExists = ((isDir) || (entry != NULL));
+    if (isDir)
+        return(1); /* definitely a dir. */
+
+    BAIL_MACRO(ERR_NO_SUCH_FILE, 0);
+} /* ROFS_isDirectory */
+
+
+static int ROFS_isSymLink(DirHandle *h, const char *name, int *fileExists)
+{
+    *fileExists = ROFS_exists(h, name);
+    return(0);  /* never symlinks in a rofs. */
+} /* ROFS_isSymLink */
+
+
+static PHYSFS_sint64 ROFS_getLastModTime(DirHandle *h,
+                                        const char *name,
+                                        int *fileExists)
+{
+    int isDir;
+    ROFSinfo *info = ((ROFSinfo *) h->opaque);
+    PHYSFS_sint64 retval = -1;
+    ROFSentry *entry = rofs_find_entry(info, name, &isDir);
+
+    *fileExists = ((isDir) || (entry != NULL));
+    if (*fileExists)  /* use time of ROFS itself in the physical filesystem. */
+        retval = info->last_mod_time;
+
+    return(retval);
+} /* ROFS_getLastModTime */
+
+
+static FileHandle *ROFS_openRead(DirHandle *h, const char *fnm, int *fileExists)
+{
+    ROFSinfo *info = ((ROFSinfo *) h->opaque);
+    FileHandle *retval;
+    ROFSfileinfo *finfo;
+    ROFSentry *entry;
+    int isDir;
+
+    entry = rofs_find_entry(info, fnm, &isDir);
+    *fileExists = ((entry != NULL) || (isDir));
+    BAIL_IF_MACRO(isDir, ERR_NOT_A_FILE, NULL);
+    BAIL_IF_MACRO(entry == NULL, ERR_NO_SUCH_FILE, NULL);
+
+    retval = (FileHandle *) malloc(sizeof (FileHandle));
+    BAIL_IF_MACRO(retval == NULL, ERR_OUT_OF_MEMORY, NULL);
+    finfo = (ROFSfileinfo *) malloc(sizeof (ROFSfileinfo));
+    if (finfo == NULL)
+    {
+        free(retval);
+        BAIL_MACRO(ERR_OUT_OF_MEMORY, NULL);
+    } /* if */
+
+    finfo->handle = __PHYSFS_platformOpenRead(info->filename);
+    if ( (finfo->handle == NULL) ||
+         (!__PHYSFS_platformSeek(finfo->handle, entry->startPos)) )
+    {
+        free(finfo);
+        free(retval);
+        return(NULL);
+    } /* if */
+
+    finfo->curPos = 0;
+    finfo->entry = entry;
+    retval->opaque = (void *) finfo;
+    retval->funcs = &__PHYSFS_FileFunctions_ROFS;
+    retval->dirHandle = h;
+    return(retval);
+} /* ROFS_openRead */
+
+
+static FileHandle *ROFS_openWrite(DirHandle *h, const char *name)
+{
+    BAIL_MACRO(ERR_NOT_SUPPORTED, NULL);
+} /* ROFS_openWrite */
+
+
+static FileHandle *ROFS_openAppend(DirHandle *h, const char *name)
+{
+    BAIL_MACRO(ERR_NOT_SUPPORTED, NULL);
+} /* ROFS_openAppend */
+
+
+static int ROFS_remove(DirHandle *h, const char *name)
+{
+    BAIL_MACRO(ERR_NOT_SUPPORTED, 0);
+} /* ROFS_remove */
+
+
+static int ROFS_mkdir(DirHandle *h, const char *name)
+{
+    BAIL_MACRO(ERR_NOT_SUPPORTED, 0);
+} /* ROFS_mkdir */
+
+#endif  /* defined PHYSFS_SUPPORTS_ROFS */
+
+/* end of rofs.c ... */
+
diff -Naur --exclude=Makefile.in --exclude=aclocal.m4 --exclude='config.*' --exclude=configure --exclude=depcomp --exclude=install-sh --exclude=ltmain.sh --exclude=missing /home/patrice/src/cvs/Icculus/physfs-stable-1.0/configure.in physfs/configure.in
--- /home/patrice/src/cvs/Icculus/physfs-stable-1.0/configure.in	2007-05-05 23:27:08.000000000 +0200
+++ physfs/configure.in	2007-05-07 17:36:23.000000000 +0200
@@ -172,6 +172,15 @@
 fi
 
 
+dnl Check for rofs archiver inclusion...
+AC_ARG_ENABLE(rofs,
+[  --enable-rofs              enable Resident Evil 3 rofs DAT support [default=yes]],
+                , enable_rofs=yes)
+if test x$enable_rofs = xyes; then
+  AC_DEFINE([PHYSFS_SUPPORTS_ROFS], 1, [define if rofs support is enabled])
+fi
+
+
 dnl Check for qpak archiver inclusion...
 AC_ARG_ENABLE(qpak,
 [  --enable-qpak              enable Quake PAK support [default=yes]],
diff -Naur --exclude=Makefile.in --exclude=aclocal.m4 --exclude='config.*' --exclude=configure --exclude=depcomp --exclude=install-sh --exclude=ltmain.sh --exclude=missing /home/patrice/src/cvs/Icculus/physfs-stable-1.0/physfs.c physfs/physfs.c
--- /home/patrice/src/cvs/Icculus/physfs-stable-1.0/physfs.c	2007-05-05 23:27:08.000000000 +0200
+++ physfs/physfs.c	2007-05-14 21:48:04.000000000 +0200
@@ -74,6 +74,11 @@
 extern const DirFunctions         __PHYSFS_DirFunctions_MVL;
 #endif
 
+#if (defined PHYSFS_SUPPORTS_ROFS)
+extern const PHYSFS_ArchiveInfo   __PHYSFS_ArchiveInfo_ROFS;
+extern const DirFunctions         __PHYSFS_DirFunctions_ROFS;
+#endif
+
 #if (defined PHYSFS_SUPPORTS_WAD)
 extern const PHYSFS_ArchiveInfo   __PHYSFS_ArchiveInfo_WAD;
 extern const DirFunctions         __PHYSFS_DirFunctions_WAD;
@@ -104,6 +109,10 @@
     &__PHYSFS_ArchiveInfo_MVL,
 #endif
 
+#if (defined PHYSFS_SUPPORTS_ROFS)
+    &__PHYSFS_ArchiveInfo_ROFS,
+#endif
+
 #if (defined PHYSFS_SUPPORTS_WAD)
     &__PHYSFS_ArchiveInfo_WAD,
 #endif
@@ -135,6 +144,10 @@
     &__PHYSFS_DirFunctions_MVL,
 #endif
 
+#if (defined PHYSFS_SUPPORTS_ROFS)
+    &__PHYSFS_DirFunctions_ROFS,
+#endif
+
 #if (defined PHYSFS_SUPPORTS_WAD)
     &__PHYSFS_DirFunctions_WAD,
 #endif
diff -Naur --exclude=Makefile.in --exclude=aclocal.m4 --exclude='config.*' --exclude=configure --exclude=depcomp --exclude=install-sh --exclude=ltmain.sh --exclude=missing /home/patrice/src/cvs/Icculus/physfs-stable-1.0/physfs_internal.h physfs/physfs_internal.h
--- /home/patrice/src/cvs/Icculus/physfs-stable-1.0/physfs_internal.h	2007-05-05 23:27:08.000000000 +0200
+++ physfs/physfs_internal.h	2007-05-07 18:09:55.000000000 +0200
@@ -52,6 +52,7 @@
  #define QPAK_ARCHIVE_DESCRIPTION "Quake I/II format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip compatible"
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format"
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format"
 
  #define ERR_IS_INITIALIZED       "Already initialized"
  #define ERR_NOT_INITIALIZED      "Not initialized"
@@ -150,6 +151,7 @@
  #define QPAK_ARCHIVE_DESCRIPTION "Quake I/II format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip kompatibel"
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format"
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format"
 
  #define ERR_IS_INITIALIZED       "Bereits initialisiert"
  #define ERR_NOT_INITIALIZED      "Nicht initialisiert"
@@ -247,6 +249,7 @@
  #define MVL_ARCHIVE_DESCRIPTION  "Descent II Movielib format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip ”œ◊Õ≈”‘…ÕŸ "
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format" // !!! FIXME: translate this line if needed
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // !!! FIXME: translate
 
  #define ERR_IS_INITIALIZED       "ı÷≈ …Œ…√…¡Ã…⁄…“œ◊¡Œ"
  #define ERR_NOT_INITIALIZED      "Ó≈ …Œ…√…¡Ã…⁄…“œ◊¡Œ"
@@ -344,6 +347,7 @@
  #define MVL_ARCHIVE_DESCRIPTION  "Descent II Movielib format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip ÒÓ‚ÏÂÒÚËÏ˚È"
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format" // FIXME: translate this line if needed
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // FIXME: translate
 
  #define ERR_IS_INITIALIZED       "”ÊÂ ËÌËˆË‡ÎËÁËÓ‚‡Ì"
  #define ERR_NOT_INITIALIZED      "ÕÂ ËÌËˆË‡ÎËÁËÓ‚‡Ì"
@@ -441,6 +445,7 @@
  #define MVL_ARCHIVE_DESCRIPTION  "Descent II Movielib format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip ·Æ¢¨•·‚®¨Î©"
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format" // FIXME: Translate this line if needed
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // FIXME: translate
 
  #define ERR_IS_INITIALIZED       "ì¶• ®≠®Ê®†´®ß®‡Æ¢†≠"
  #define ERR_NOT_INITIALIZED      "ç• ®≠®Ê®†´®ß®‡Æ¢†≠"
@@ -538,6 +543,7 @@
  #define MVL_ARCHIVE_DESCRIPTION  "Descent II Movielib format"
  #define ZIP_ARCHIVE_DESCRIPTION  "PkZip/WinZip/Info-Zip ·ﬁ“‹’·‚ÿ‹ÎŸ"
  #define WAD_ARCHIVE_DESCRIPTION  "DOOM engine format"  // FIXME: translate this line if needed
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // FIXME: translate
 
  #define ERR_IS_INITIALIZED       "√÷’ ÿ›ÿÊÿ–€ÿ◊ÿ‡ﬁ“–›"
  #define ERR_NOT_INITIALIZED      "Ω’ ÿ›ÿÊÿ–€ÿ◊ÿ‡ﬁ“–›"
@@ -637,6 +643,7 @@
  #define QPAK_ARCHIVE_DESCRIPTION "Quake I/II format"
  #define ZIP_ARCHIVE_DESCRIPTION  "Compatible PkZip/WinZip/Info-Zip"
  #define WAD_ARCHIVE_DESCRIPTION  "Format WAD du moteur DOOM"
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // FIXME: translate
 
  #define ERR_IS_INITIALIZED       "DÈj‡ initialisÈ"
  #define ERR_NOT_INITIALIZED      "Non initialisÈ"
@@ -735,6 +742,7 @@
  #define QPAK_ARCHIVE_DESCRIPTION "Formato Quake I/II"
  #define ZIP_ARCHIVE_DESCRIPTION  "Formato compatÌvel PkZip/WinZip/Info-Zip"
  #define WAD_ARCHIVE_DESCRIPTION  "Formato WAD do engine DOOM"
+ #define ROFS_ARCHIVE_DESCRIPTION "Resident Evil 3 format" // FIXME: translate
 
  #define ERR_IS_INITIALIZED       "J· inicializado"
  #define ERR_NOT_INITIALIZED      "N„o inicializado"
